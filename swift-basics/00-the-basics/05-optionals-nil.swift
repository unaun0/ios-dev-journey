/*
Опциональные типы
*/

// Опциональные типы Type? используются в ситуациях, когда значение может отсутствовать.
// Опциональный тип представляет две возможности: 
// либо есть значение указанного типа, и вы можете развернуть опциональный тип, чтобы получить доступ к этому значению, 
// либо нет никакого значения.

let possibleNumber = "123"
let convertedNumber = Int(possibleNumber) // "optional Int"
print(convertedNumber ?? 0) // ?? 0 - задано значение по умолчанию 0, если convertedNumber - nil.

var serverResponseCode: Int? = 404
serverResponseCode = nil // No value

// Если определяется необязательная переменная без инициализации, то значение переменной nil

var surveyAnswer: String? // nil

// В Objective-C, nil является указателем на несуществующий объект; оно может быть присвоено только переменным, которые хранят указатели на объекты.
// В Swift, nil — это не указатель, а отсутствие значения определённого типа; которое может быть присвоено переменным любого типа.

// Можно использовать необязательную привязку, чтобы узнать, содержит ли необязательное значение, 
// и если да, то сделать это значение доступным в качестве временной константы или переменной. 
// Необязательную привязку можно использовать с операторами if, guard, и while для проверки наличия значения 
// внутри необязательного значения и извлечения этого значения в константу или переменную в рамках одного действия.

if let actualNumber = Int(possibleNumber) {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("The string \"\(possibleNumber)\" couldn't be converted to an integer")
}

// В один оператор if можно включить столько необязательных привязок и логических условий, 
// сколько необходимо, разделив их запятыми. 
// Если какое-либо из значений в необязательных привязках равно nil или какое-либо логическое условие оценивается 
// как false, то условие всего оператора if считается false.

if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
    print("\(firstNumber) < \(secondNumber) < 100")
}

if let firstNumber = Int("4") {
    if let secondNumber = Int("42") {
        if firstNumber < secondNumber && secondNumber < 100 {
            print("\(firstNumber) < \(secondNumber) < 100")
        }
    }
}

// Константы и переменные, созданные с необязательной привязкой в if инструкции, доступны только в теле if инструкции. 
// Напротив, константы и переменные, созданные с помощью guard инструкции, доступны в строках кода, следующих 
// за guard инструкцией

// Другой способ обработки отсутствующего значения — задать значение по умолчанию 
// с помощью оператора объединения с нулевым значением (??).

let name: String? = nil
let greeting = "Hello, " + (name ?? "friend") + "!"
print(greeting) // "Hello, friend!"

// Остановить выполнение программы можно с помощью оператора !.
// Если nil представляет собой неисправимую ошибку, например, ошибку программиста или повреждённое состояние, 
// вы можете получить доступ к базовому значению, добавив восклицательный знак (!) в конец имени необязательного значения. 
// Это называется принудительным раскрытием значения необязательного типа. При принудительном раскрытии значения,
// отличного от nil, результатом будет его раскрытое значение. Принудительное раскрытие значения nil приводит к ошибке
// во время выполнения.

var optionalString: String? = "Привет, мир!"
print(optionalString!) // Выведет "Привет, мир!"
optionalString = nil
print(optionalString) // "nil"
// print(optionalString!) // Программа завершится с ошибкой 
// ! — это, по сути, более короткое написание fatalError(_:file:line:).

// Неявно развёрнутый необязательный параметр — это обычный необязательный параметр, 
// который используется за кулисами, но может использоваться и как необязательное значение 
// без необходимости разворачивать необязательное значение при каждом обращении к нему. 

let possibleString: String? = "An optional string."
let forcedString: String = possibleString!

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString
// Вам дан массив целых чисел nums длиной n, индексируемый с 0. 
// Изначально вы находитесь на позиции nums[0].
// Каждый элемент nums[i] определяет максимальную длину прыжка из индекса i. 
// То есть, если вы находитесь на nums[i], вы можете прыгнуть на любой индекс nums[i + j], где:
// 0 <= j <= nums[i]
// i + j < n
//
// Задача: Верните минимальное количество прыжков,
// необходимое для достижения последнего элемента nums[n - 1]. 
// Тестовые случаи составлены так, что достичь последнего элемента всегда возможно.
//
// Пример 1:
// Входные данные: nums = [2, 3, 1, 1, 4]
// Выходные данные: 2
// Объяснение:
// Минимальное количество прыжков:
// Прыжок на 1 шаг с индекса 0 → индекс 1 (значение 3).
// Прыжок на 3 шага с индекса 1 → последний индекс 4.
//
// Пример 2:
// Входные данные: nums = [2, 3, 0, 1, 4]
// Выходные данные: 2
// Объяснение:
// Минимальное количество прыжков:
//
// Прыжок на 1 шаг с индекса 0 → индекс 1 (значение 3).
// Прыжок на 3 шага с индекса 1 → последний индекс 4.
// Ограничения:
//
// 1 <= nums.length <= 10^4
// 0 <= nums[i] <= 1000
// Гарантируется, что последний элемент достижим.

class Solution {
    func jump(_ nums: [Int]) -> Int {
        var jumps = 0
        var currentEnd = 0
        var maxReach = 0
        
        for i in 0..<nums.count - 1 {
            maxReach = max(maxReach, i + nums[i])
            if i == currentEnd {
                jumps += 1
                currentEnd = maxReach
            }
        }
        return jumps
    }
}
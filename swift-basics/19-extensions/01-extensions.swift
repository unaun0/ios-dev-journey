/*
Расширения
*/

// Расширения в Swift — мощный инструмент для добавления новой функциональности уже существующим типам, 
// таким как классы, структуры и перечисления, без необходимости изменять исходный код этих типов. 

// В отличие от категорий в Objective-C, расширения в Swift не имеют имени, что делает их удобными для 
// ретроактивного моделирования — то есть, добавления функциональности типам, к исходному коду которых 
// у вас нет доступа.

/* Добавление вычисляемых свойств */

// Расширения могут добавлять новые вычисляемые свойства к существующим типам. 
// Это полезно для создания дополнительных методов обработки данных без необходимости изменять исходный тип.

extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
}
let distanceInKm = 2.0.km // 2000.0

/* Добавление инициализаторов */

// Расширения могут добавлять новые инициализаторы к типам, 
// что позволяет создавать новые способы инициализации существующих объектов.

struct Point {
    var x = 0.0, y = 0.0
}

extension Point {
    init(x: Double) {
        self.x = x
        self.y = 0.0
    }
}

let origin = Point(x: 5.0) // Создаем точку с x=5.0 и y=0.0

/* Добавление методов экземпляра и методов типа */

// Методы экземпляра могут быть добавлены к типам через расширения, что позволяет им выполнять 
// дополнительные операции или обрабатывать данные.

extension Int {
    func repetitions(task: () -> Void) {
        for _ in 0..<self {
            task()
        }
    }
}

3.repetitions {
    print("Hello!")
}
// Выведет:
// Hello!
// Hello!
// Hello!

/* Изменяющие методы (mutating) */

// Методы, добавленные в расширение для структур или перечислений, могут изменять состояние экземпляра, 
// но такие методы должны быть помечены как mutating.

extension Int {
    mutating func square() {
        self = self * self
    }
}
var number = 3
number.square() // number теперь 9

/* Добавление сабскриптов */

// Расширения могут добавлять новые сабскрипты (индексы) для типов. 
// Это полезно, например, для доступа к элементам коллекции или данных в типах,
// где это не было предусмотрено изначально.

import Foundation 

extension Int {
    subscript(digitIndex: Int) -> Int {
        let digits = String(self).reversed() // Реверсируем строку
        // Преобразуем digitIndex в подходящий индекс для реверсированного массива
        let index = digits.index(digits.startIndex, offsetBy: digitIndex) 
        return Int(String(digits[index])) ?? 0 // Получаем цифру по индексу
    }
}
let number1 = 123456
print(number1[0]) // Выведет 6
print(number1[1]) // Выведет 5

/* Добавление вложенных типов */

// Расширения могут добавлять новые вложенные типы к существующим типам, 
// что позволяет создавать дополнительные структуры или перечисления, связанные с типом.

extension Int {
    enum Kind {
        case negative, zero, positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .zero
        case let x where x > 0:
            return .positive
        default:
            return .negative
        }
    }
}

let number3 = -5
print(number3.kind) // Выведет "negative"

/* Соответствие протоколам */

// Расширения могут использоваться для того, чтобы тип начал соответствовать одному или нескольким протоколам. 
// Это особенно полезно, если вы хотите, чтобы тип выполнял требования протокола, но не можете изменить 
// его исходный код.

protocol Describable {
    var description: String { get }
}

extension Int: Describable {
    var description: String {
        return "This is the number \(self)"
    }
}

let number4 = 42
print(number4.description) // Выведет "This is the number 42"

/* Ограничения */
/*
Не могут быть добавлены свойства хранения или наблюдатели свойств: 
    Расширения могут добавлять только вычисляемые свойства, но не могут добавить новое хранимое свойство.
Не могут изменять уже существующие методы: 
    Вы не можете переопределить или изменять методы, уже определенные для типа. Вы можете только добавлять новые.
Не могут добавлять назначенные инициализаторы для классов: 
    Расширения могут добавлять вспомогательные инициализаторы, но не могут 
    заменить или добавлять назначенные инициализаторы для классов.
*/


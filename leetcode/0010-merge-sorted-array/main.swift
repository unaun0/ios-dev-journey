// Даны два массива целых чисел nums1 и nums2, отсортированных в порядке неубывания, и два целых числа m и n,
// представляющих количество элементов в nums1 и nums2 соответственно.
// Объедините nums1 и nums2 в один массив, отсортированный в порядке неубывания.
// Итоговый отсортированный массив должен быть сохранен внутри массива nums1 (не возвращаться функцией). 
//
// Для этого:
// nums1 имеет длину m + n
// Первые m элементов — значимые
// Последние n элементов установлены в 0 и должны быть проигнорированы
// nums2 имеет длину n
//
// Примеры:
//
// Пример 1:
//
// Вход: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
// Выход: [1,2,2,3,5,6]
// Объединяем [1,2,3] и [2,5,6]. Результат — [1,2,2,3,5,6] (подчеркнутые элементы из nums1).
//
// Пример 2:
//
// Вход: nums1 = [1], m = 1, nums2 = [], n = 0
// Выход: [1]
// Объединяем [1] и []. Результат — [1].
//
// Пример 3:
//
// Вход: nums1 = [0], m = 0, nums2 = [1], n = 1
// Выход: [1]
// Объединяем [] и [1]. Результат — [1] (m=0 означает, что в nums1 нет элементов, только место для объединения).
//
// Ограничения:
//
// nums1.length == m + n
// nums2.length == n
// 0 <= m, n <= 200
// 1 <= m + n <= 200
// -10^9 <= nums1[i], nums2[j] <= 10^9
//
// Дополнительно:
//
// Можете ли вы предложить алгоритм со сложностью O(m + n)?

class Solution {
    func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) {
        var i = m - 1
        var j = n - 1
        var k = m + n - 1
        while k >= 0 {
            if j < 0 {
                break
            } else if i < 0 {
                nums1[k] = nums2[j]
                j -= 1
            } else if nums1[i] > nums2[j] {
                nums1[k] = nums1[i]
                i -= 1
            } else {
                nums1[k] = nums2[j]
                j -= 1
            }
            k -= 1
        }
    }
}
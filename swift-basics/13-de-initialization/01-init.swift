/*
Инициализация
*/

// Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего 
// использования. 
// Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и 
// проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться.

// Экземпляры классовых типов также могут реализовывать деинициализаторы, которые проводят любую чистку 
// прямо перед тем, как экземпляр класса будет освобожден.

/*
Установка начальных значений для свойств хранения
*/

// Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса 
// или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии.

// Вы можете установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, 
// как часть определения свойства.

/*
Инициализаторы

init() {
    // инициализация проводится тут
}
*/

struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("Значение температуры по умолчанию \(f.temperature)° по Фаренгейту") 
// "Значение температуры по умолчанию 32.0° по Фаренгейту"

/*
Дефолтные значения свойств
*/

// Вы можете установить исходное значение свойства в инициализаторе, как показано выше. 
// Так же вы можете указать значение свойства по умолчанию, как часть определения свойства.

struct Fahrenheit1 {
  var temperature = 32.0
}

/*
Настройка инициализации
*/

// Вы можете настроить процесс инициализации входными параметрами и опциональными типами свойств 
// или присваиванием значений для постоянных свойств во время инициализации

/*
Параметры инициализации
*/

// Параметры инициализации могут быть частью определения инициализатора, 
// для определения типов и имен значений, которые настраивают процесс инициализации. 
// Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода.

struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0

/*
Локальные и внешние имена параметров.
Параметры инициализатора без внешних имен.
*/

// Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена 
// для использования внутри тела инициализатора и внешние для использования при вызове инициализатора.

// Однако инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. 

// Если вы не хотите использовать внешние имена для параметров инициализации, напишите подчеркивание (_) 
// вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию.

/*
Опциональные типы свойств
*/

// Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения”, 
// возможно потому, что его значение не может быть установлено во время инициализации или потому, 
// что ему разрешается иметь “отсутствие значения” в какой-либо точке кода, 
// то такое свойство нужно объявить с опциональным типом.
// Свойства опционального типа автоматически инициализируются со значением nil, указывая на то, 
// что значение стремится иметь значение “пока что отсутствие значение” на этапе инициализации.

class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Нравится ли вам сыр?")
cheeseQuestion.ask() // Выведет "Нравится ли вам сыр?"
print(cheeseQuestion.response) // nil
cheeseQuestion.response = "Да, я люблю сыр"
print(cheeseQuestion.response) // Optional("Да, я люблю сыр")

/*
Присваивание значений постоянным свойствам во время инициализации
*/

// Вы можете присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса 
// инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено.

class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "Что насчет свеклы?")
beetsQuestion.ask() // "Что насчет свеклы?"
beetsQuestion.response = "Я люблю свеклу, но не в сыром виде!"

/*
Дефолтные инициализаторы
*/

// Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение 
// по умолчанию для всех его свойств и не имеет ни одного инициализатора. 
// Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями 
// по умолчанию.

class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()

// Так как все свойства класса ShoppingListItem имеют значения по умолчанию и так как этот класс не имеет суперкласса, 
// то ShoppingListItem автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр 
// со всеми свойствами с уже присвоенными значениями по умолчанию. (name - nil, quantity - 1, purchased - false).

/*
Почленные инициализаторы структурных типов
*/

// Структурные типы автоматически получают почленный инициализатор, если они не определяют своего пользовательского 
// инициализатора. Это верно даже при условии, что хранимые свойства не имеют значений по умолчанию.

// Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры. 
// Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени.

struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)

/*
Делегирование инициализатора для типов значения
*/

// Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. 
// Этот процесс называется как делегирование инициализатора. 
// Он позволяет избегать дублирования кода в разных инициализаторах.

struct Point {
    var x = 0.0, y = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
let basicRect = Rect()
//исходная точка Rect (0.0, 0.0) и его размер (0.0, 0.0)
let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))
//исходная точка Rect (2.0, 2.0) и его размер (5.0, 5.0)
let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))
//исходная точка centerRect’а равна (2.5, 2.5) и его размер (3.0, 3.0)

/*
Наследование и инициализация класса
*/

// Всем свойствам класса, включая и те, что унаследованы у суперкласса должны быть присвоены начальные значения, 
// во время их инициализации.

// Swift определяет два вида инициализаторов классовых типов для проверки того, что все свойства получили какие-либо 
// значения. Они известны как назначенные инициализаторы (конструкторы) и вспомогательные инициализаторы.

/*
Назначенный и вспомогательный инициализатор
*/

// Назначенные инициализаторы

// При реализации собственных типов данных во многих случаях не требуется создавать собственный инициализатор, так как классы
// и структуры имеют встроенные инициализаторы:
// - классы имеют пустой встроенный инициализатор init(){};
// - структуры имеют встроенный инициализатор, принимающий в качестве входных аргументов значения всех свойств.
// Пустой инициализатор срабатывает без ошибок только в том случае, если у класса отсутствуют свойства или 
// у каждого свойства указано значение по умолчанию.

// Вспомогательные инициализаторы являются вторичными, поддерживающими инициализаторами для класса.
// Вы можете определить вспомогательный инициализатор для проведения настроек и обязательного вызова одного 
// из назначенных инициализаторов. Вспомогательные инициализаторы не являются обязательными для их реализации 
// в типе. Создавайте их, если это обеспечивает наиболее рациональный путь решения поставленной задачи.

/*
Назначенные инициализаторы:
init(параметры) {
    выражения
}

Вспомогательные инициализаторы:
convenience init(параметры) {
    выражения
}
*/

// суперкласс
class Quadruped {
    var type = ""
    var name = ""
    func walk() {
        print("walk")
    }
}
// подкласс
class Quadruped {
    var type = ""
    var name = ""
    func walk() {
        print("walk")
    }
}
class Dog: Quadruped {
    override init() {
        super.init()
            self.type = "dog"
    }
    convenience init(text: String) {
        self.init()
        print(text)
    }
    func bark() {
        print("woof")
    }
    func printName() {
        print(self.name)
    }
}
var myDog = Dog(text: "Экземпляр класса Dog создан")
// Вспомогательный инициализатор может вызывать назначенный через другой вспомогательный инициализатор.

/*
Наследование инициализаторов
*/

// Наследование инициализаторов отличается от наследования обычных методов суперкласса. 
// Есть два важнейших правила, которые необходимо помнить:
    // - Если подкласс имеет собственный назначенный инициализатор, то 
    //   инициализаторы родительского класса не наследуются.
    // - Если подкласс переопределяет все назначенные инициализаторы суперкласса, то 
    //   он наследует и все его вспомогательные инициализаторы.

// Отношения между инициализаторами: 
// Назначенный инициализатор подкласса должен вызвать назначенный инициализатор суперкласса.
// Вспомогательный инциализатор должен вызвать назначенный инициализатор того же объектного типа
// Вспомогательный инициализатор в конечном счете должен вызвать назначенный инициализатор.

/*
 Суперкласс
  ┌───────────┐       ┌────────────────────┐      ┌────────────────────┐
  │  init()   │ ←───  │ convenience init() │ ←─── │ convenience init() │
  └───────────┘       └────────────────────┘      └────────────────────┘
        ↑   ↑
        │   │
        │   +─────────────────+      
 Подкласс                     │
  ┌───────────┐         ┌───────────┐       ┌────────────────────┐
  │  init()   │         │  init()   │ ←───  │ convenience init() │
  └───────────┘         └───────────┘       └────────────────────┘
*/

/*
Проваливающиеся инициализаторы
*/

// В некоторых ситуациях бывает необходимо определить объектный тип, создание экземпляра которого может 
// закончиться неудачей, вызванной некорректным набором внешних параметров, отсутствием какого-либо внешнего 
// ресурса или иным обстоятельством. Для этой цели служат проваливающиеся (failable) инициализаторы. 
// Они способны возвращать nil при попытке создания экземпляра. И это их основное предназначение.

/*
В теле инициализатора должно присутствовать выражение return nil.

init? (параметры) {
    // тело инициализатора
}
*/

class Rectangle {
    var height: Int
    var weight: Int
    
    init?(height h: Int, weight w: Int) {
        if !(h > 0 && w > 0) {
            return nil
        }
        self.height = h
        self.weight = w
    }
}
var rectangle = Rectangle(height: 56, weight: -32) // возвращает nil

// В классах проваливающийся инициализатор может вернуть nil только после установки значений всех хранимых 
// свойств. В случае структур данное ограничение отсутствует.

/*
Обязательные инициализаторы
*/

// Обязательный (required) инициализатор — это инициализатор, который обязательно должен быть определен во 
// всех подклассах данного класса.
// Для объявления обязательного инициализатора перед ключевым словом init указывается модификатор required.
// Кроме того, модификатор required необходимо указывать перед каждой реализацией данного инициализатора 
// в подклассах, чтобы последующие подклассы также реализовывали этот инициализатор (о override не используется).

class Base {
    var value: Int
    
    required init(value: Int) {
        self.value = value
    }
}

class Derived: Base {
    required init(value: Int) {
        super.init(value: value)
    }
}
/*
Целые числа
*/

// Целые числа — это целые числа без дробной части. 
// Целые числа могут быть со знаком (положительными, нулевыми или отрицательными) 
// или без знака (положительными или нулевыми).
// Swift предоставляет целочисленные типы со знаком и без знака в 8-, 16-, 32- и 64-разрядных форматах. 
// Эти целочисленные типы имеют имена, аналогичные C, то есть 8-разрядное целое число без знака имеет тип UInt8, 
// а 32-разрядное целое число со знаком — тип Int32. 
// Как и все типы в Swift, эти целочисленные типы имеют имена, написанные заглавными буквами.

// В Swift также есть два целочисленных типа, которые не имеют конкретной размерности,
// Int и UInt, которые могут быть представлены как 32- или 64-разрядные
// целые числа, в зависимости от платформы, на которой работает программа.

var a: Int8 = -5
var b: UInt32 = 32
var c: Int = 10
var d: UInt = 20

print(a, b, c, d)

/*
Целые числа - целочисленные границы
*/

// Получить доступ к минимальным и максимальным значениям каждого целочисленного типа с помощью свойств min и max

let minValue = UInt8.min  // 0
let maxValue = UInt8.max  // 255

/*
Числа с плавающей запятой
*/

// Числа с плавающей запятой — это числа с дробной частью, такие как 3.14159, 0.1, и -273.15.

// Swift предоставляет два типа чисел с плавающей запятой со знаком:
// Double представляет собой 64-разрядное число с плавающей запятой.
// Float представляет собой 32-разрядное число с плавающей запятой.

// Double имеет точность не менее 15 знаков после запятой, в то время как точность Float может 
// составлять всего 6 знаков после запятой. Выбор подходящего типа с плавающей запятой зависит от 
// характера и диапазона значений, с которыми вам нужно работать в коде. 
// В ситуациях, когда подходит любой из этих типов, Double предпочтительнее.

var f: Float = 43.2
var dd: Double = -231.3

/*
Безопасность типа и вывод типа
*/

// Swift — это типобезопасный язык.
// Swift выполняет проверку типов при компиляции кода и помечает все несовпадающие типы как ошибки.

let meaningOfLife = 42 // Int
let pi = 3.14159 // Double
let anotherPi = 3 + 0.14159 // Double

/*
Числовые литералы
*/

// Целочисленные литералы могут быть записаны в виде:
    // Десятичное число без префикса
    // Двоичное число с 0b префиксом
    // Восьмеричное число с 0o префиксом
    // Шестнадцатеричное число с 0x префиксом

let decimalInteger = 17
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

// Литералы с плавающей запятой могут быть десятичными (без префикса) или шестнадцатеричными (с префиксом 0x). 
// Они всегда должны содержать число (или шестнадцатеричное число) по обе стороны от десятичной точки. 
// Десятичные числа с плавающей запятой также могут иметь необязательный показатель степени, 
// обозначаемый заглавной или строчной буквой e. 
// Шестнадцатеричные числа с плавающей запятой должны иметь показатель степени, обозначаемый заглавной или строчной буквой p.

let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0

// Числовые литералы могут содержать дополнительные символы форматирования, чтобы их было легче читать. 
// И целые числа, и числа с плавающей точкой могут дополняться нулями и содержать подчёркивания для удобства чтения. 
// Ни один из этих типов форматирования не влияет на базовое значение литерала:

let paddedDouble = 000123.456
let oneMillion = 000_1_000_000
let justOverOneMillion = 1_000_000.000_000_1

/*
Преобразование типа
*/

// let cannotBeNegative: UInt8 = -1 // Ошибка
// let tooBig: Int8 = Int8.max + 1 // Ошибка, переполнение 

let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
// let twoThousandAndOne = twoThousand + one // Ошибка - разные типы
let twoThousandAndOne = twoThousand + UInt16(one) // Необходимо приводить к большему

// SomeType(ofInitialValue) - это способ вызова инициализатора Swift-типа по умолчанию 
// с передачей начального значения. За кулисами UInt16 имеет инициализатор, принимающий UInt8 значение, 
// и этот инициализатор используется для создания нового UInt16 из существующего UInt8. 
// Однако здесь нельзя передать любой тип — это должен быть тип, для которого UInt16 предоставляет инициализатор. 
// Расширение существующих типов для предоставления инициализаторов, принимающих новые типы 
// (включая собственные определения типов), описано в расширениях.

let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi2 = Double(three) + pointOneFourOneFiveNine // Double
let piInt = Int(pi2) // Int

// Правила объединения числовых констант и переменных отличаются от правил для числовых литералов. 
// Значение литерала 3 можно добавить непосредственно к значению литерала 0.14159, 
// потому что числовые литералы сами по себе не имеют явного типа. 
// Их тип определяется только в момент их вычисления компилятором.

/*
Псевдонимы типов
*/

// Псевдонимы типов определяют альтернативное имя для существующего типа. 
// Псевдонимы типов определяются с помощью ключевого слова typealias

typealias AudioSample = UInt16
var maxAmplitudeFound = AudioSample.min // 0

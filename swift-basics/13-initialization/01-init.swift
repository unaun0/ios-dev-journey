/*
Инициализация
*/

// Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего 
// использования. 
// Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и 
// проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться.

// Экземпляры классовых типов также могут реализовывать деинициализаторы, которые проводят любую чистку 
// прямо перед тем, как экземпляр класса будет освобожден.

/*
Установка начальных значений для свойств хранения
*/

// Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса 
// или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии.

// Вы можете установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, 
// как часть определения свойства.

/*
Инициализаторы

init() {
    // инициализация проводится тут
}
*/

struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("Значение температуры по умолчанию \(f.temperature)° по Фаренгейту") 
// "Значение температуры по умолчанию 32.0° по Фаренгейту"

/*
Дефолтные значения свойств
*/

// Вы можете установить исходное значение свойства в инициализаторе, как показано выше. 
// Так же вы можете указать значение свойства по умолчанию, как часть определения свойства.

struct Fahrenheit1 {
  var temperature = 32.0
}

/*
Настройка инициализации
*/

// Вы можете настроить процесс инициализации входными параметрами и опциональными типами свойств 
// или присваиванием значений для постоянных свойств во время инициализации

/*
Параметры инициализации
*/

// Параметры инициализации могут быть частью определения инициализатора, 
// для определения типов и имен значений, которые настраивают процесс инициализации. 
// Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода.

struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0

/*
Локальные и внешние имена параметров.
Параметры инициализатора без внешних имен.
*/

// Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена 
// для использования внутри тела инициализатора и внешние для использования при вызове инициализатора.

// Однако инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. 

// Если вы не хотите использовать внешние имена для параметров инициализации, напишите подчеркивание (_) 
// вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию.

/*
Опциональные типы свойств
*/

// Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения”, 
// возможно потому, что его значение не может быть установлено во время инициализации или потому, 
// что ему разрешается иметь “отсутствие значения” в какой-либо точке кода, 
// то такое свойство нужно объявить с опциональным типом.
// Свойства опционального типа автоматически инициализируются со значением nil, указывая на то, 
// что значение стремится иметь значение “пока что отсутствие значение” на этапе инициализации.

class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Нравится ли вам сыр?")
cheeseQuestion.ask() // Выведет "Нравится ли вам сыр?"
print(cheeseQuestion.response) // nil
cheeseQuestion.response = "Да, я люблю сыр"
print(cheeseQuestion.response) // Optional("Да, я люблю сыр")

/*
Присваивание значений постоянным свойствам во время инициализации
*/

// Вы можете присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса 
// инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено.

class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let beetsQuestion = SurveyQuestion(text: "Что насчет свеклы?")
beetsQuestion.ask() // "Что насчет свеклы?"
beetsQuestion.response = "Я люблю свеклу, но не в сыром виде!"

/*
Дефолтные инициализаторы
*/

// Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение 
// по умолчанию для всех его свойств и не имеет ни одного инициализатора. 
// Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями 
// по умолчанию.

class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()

// Так как все свойства класса ShoppingListItem имеют значения по умолчанию и так как этот класс не имеет суперкласса, 
// то ShoppingListItem автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр 
// со всеми свойствами с уже присвоенными значениями по умолчанию. (name - nil, quantity - 1, purchased - false).

/*
Почленные инициализаторы структурных типов
*/

// Структурные типы автоматически получают почленный инициализатор, если они не определяют своего пользовательского 
// инициализатора. Это верно даже при условии, что хранимые свойства не имеют значений по умолчанию.

// Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры. 
// Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени.

struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)

/*
Делегирование инициализатора для типов значения
*/

// Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. 
// Этот процесс называется как делегирование инициализатора. 
// Он позволяет избегать дублирования кода в разных инициализаторах.

struct Point {
    var x = 0.0, y = 0.0
}

struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
let basicRect = Rect()
//исходная точка Rect (0.0, 0.0) и его размер (0.0, 0.0)
let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))
//исходная точка Rect (2.0, 2.0) и его размер (5.0, 5.0)
let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))
//исходная точка centerRect’а равна (2.5, 2.5) и его размер (3.0, 3.0)

/*
Наследование и инициализация класса
*/

// Всем свойствам класса, включая и те, что унаследованы у суперкласса должны быть присвоены начальные значения, 
// во время их инициализации.

// Swift определяет два вида инициализаторов классовых типов для проверки того, что все свойства получили какие-либо 
// значения. Они известны как назначенные инициализаторы (конструкторы) и вспомогательные инициализаторы.

/*
Назначенный и вспомогательный инициализатор
*/

// Назначенные инициализаторы в основном инициализаторы класса. 
// Они предназначены для того, чтобы полностью инициализировать все свойства представленные классом и 
// чтобы вызвать соответствующий инициализатор суперкласса для продолжения процесса инициализации цепочки 
// наследо

// Вспомогательные инициализаторы являются вторичными, поддерживающими инициализаторами для класса. 
// Вы можете определить вспомогательный инициализатор для вызова назначенного инициализатора из того же класса, 
// что и вспомогательный инициализатор с некоторыми параметрами назначенного инициализатора с установленными 
// начальными значениями.

/*

Назначенные инициализаторы:
init(параметры) {
    выражения
}

Вспомогательные инициализаторы:
convenience init(параметры) {
    выражения
}
*/




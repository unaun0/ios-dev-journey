/*
Переопределение
*/

// Подклассы могут проводить свои собственные реализации методов экземпляра, методов класса, свойств экземпляра, 
// свойств класса или индекса, который в противном случае будет наследовать от суперкласса. 
// Это известно как переопределение.

// Для переопределения характеристик, которые все равно будут унаследованы, вы приписываете к 
// переписываемому определению ключевое слово override.

// Когда вы проводите переопределение метода, свойства, индекса для подкласса, 
// иногда бывает полезно использовать существующую реализацию суперкласса как часть вашего переопределения. 

// Там, где это уместно, вы можете получить доступ к методу, свойству, индексу версии суперкласса, 
// если будете использовать префикс super:
    // Переопределенный метод someMethod может вызвать версию суперкласса метода someMethod, 
        // написав super.someMethod() внутри переопределения реализации метода.
    // Переопределённое свойство someProperty может получить доступ к свойству версии суперкласса 
        // someProperty как super.someProperty внутри переопределения реализации геттера или сеттера.
    // Переопределенный индекс для someIndex может получить доступ к версии суперкласса 
        // того же индекса как super[someIndex] изнутри переопределения реализации индекса.

/*
Переопределение методов
*/

class Vehicle {
    var currentSpeed = 0.0
    var description: String {
        return "движется на скорости \(currentSpeed) миль в час"
    }
    func makeNoise() {
    }
}

class Train: Vehicle {
    override func makeNoise() {
        print("Чу-чу")
    }
}

let train = Train()
train.makeNoise() // Чу-чу

/*
Переопределение свойств
*/

// Вы можете переопределить унаследованные свойства класса или экземпляра для установки вашего собственного геттера 
// и сеттера для этого свойства, или добавить наблюдателя свойства для наблюдения за переопределяемым свойством, 
// когда меняется лежащее в основе значение свойства.

/*
Переопределения геттеров и сеттеров свойства
*/

class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " на передаче \(gear)"
    }
}
let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print("Машина: \(car.description)") // Машина: движется на скорости 25.0 миль в час на передаче 3

/*
Переопределение наблюдателей свойства
*/

// Вы можете использовать переопределение свойства для добавления наблюдателей к унаследованному свойству.
// Это позволяет вам получать уведомления об изменении значения унаследованного свойства, несмотря на то, 
// как изначально это свойство было реализовано. 

class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}
let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
print("Машина с автоматом: \(automatic.description)") 
// Машина с автоматом: движется на скорости 35.0 миль в час на передаче 4

/*
Предотвращение переопределений
*/

// Вы можете предотвратить переопределение метода, свойства или индекса, обозначив его как конечный. 
// Сделать это можно написав ключевое слово final перед ключевым словом метода, 
// свойства или индекса (final var, final func, final class func, и final subscript ).

// Любая попытка переписать конечный метод, свойство или индекс в подклассе приведет к ошибке компиляции. 
// Методы, свойства и индексы, которые вы добавляете в класс в расширении, так же могут быть отмечены 
// как конечные внутри определения расширения.

// Вы можете отметить целый класс как конечный или финальный, написав слово final перед ключевым словом class 
// (final class). Любая попытка унаследовать класс также приведет к ошибке компиляции.


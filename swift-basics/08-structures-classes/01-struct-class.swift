/*
Структуры и классы
*/

// Swift не требует создавать отдельные файлы для интерфейсов и реализаций пользовательских классов и структур. 
// В Swift, вы объявляете структуру или класс в одном файле, и внешний интерфейс автоматически становится доступным 
// для использования в другом коде.

// Экземпляр класса традиционно называют объектом.

// Сравнение классов и структур
// Классы и структуры в Swift имеют много общего. И в классах и в структурах можно:
    // Объявлять свойства для хранения значений
    // Объявлять методы, чтобы обеспечить функциональность
    // Объявлять индексы, чтобы обеспечить доступ к их значениям, через синтаксис индексов
    // Объявлять инициализаторы, чтобы установить их первоначальное состояние
    // Они оба могут быть расширены, чтобы расширить их функционал за пределами стандартной реализации
    // Они оба могут соответствовать протоколам, для обеспечения стандартной функциональности определенного типа
// Классы имеют дополнительные возможности, которых нет у структур:
    // Наследование позволяет одному классу наследовать характеристики другого
    // Приведение типов позволяет проверить и интерпретировать тип экземпляра класса в процессе выполнения
    // Деинициализаторы позволяют экземпляру класса освободить любые ресурсы, которые он использовал
    // Подсчет ссылок допускает более чем одну ссылку на экземпляр класса. 

/*
Синтаксис объявления
*/

class SomeClass {
    // здесь пишется определение класса
}
struct SomeStructure {
    // здесь пишется определение структуры
}

struct Resolution {
    var width = 0
    var height = 0
}
class VideoMode {
    var resolution = Resolution()
    var interlaced = false
    var frameRate = 0.0
    var name: String?
}

/*
Экземпляры класса и структуры
*/

let someResolution = Resolution()
let someVideoMode = VideoMode()

/*
Доступ к свойствам
*/

print("The width of someResolution is \(someResolution.width)") // "The width of someResolution is 0"
print("The width of someVideoMode is \(someVideoMode.resolution.width)") // "The width of someVideoMode is 0"

someVideoMode.resolution.width = 1280
print("The width of someVideoMode is now \(someVideoMode.resolution.width)") // "The width of someVideoMode is now 1280"

/*
Поэлементные инициализаторы структурных типов
*/

// Все структуры имеют автоматически генерированный "поэлементный инициализатор", 
// который вы можете использовать для инициализации свойств новых экземпляров структуры. 
// Начальные значения для свойств нового экземпляра могут быть переданы поэлементному инициализатору по имени

let vga = Resolution(width: 640, height: 480)

// В отличие от структур, классы не получили поэлементного инициализатора исходных значений. 

/*
Структуры и перечисления - типы значения
*/

// Тип значения - это тип, значение которого копируется, когда оно присваивается константе или переменной, 
// или когда передается функции.
// Все базовые типы Swift - типы значений и реализованы они как структуры.
// Все структуры и перечисления - типы значений в Swift. 
// Это значит, что любой экземпляр структуры и перечисления, который вы создаете, и любые типы значений, 
// которые они имеют в качестве свойств, всегда копируются, когда он передается по вашему коду.

let hd = Resolution(width: 1920, height: 1080)
var cinema = hd

// Так как Resolution - структура, делается копия существующего экземпляра, и эта новая копия присваивается cinema. 
// Даже несмотря на то, что hd и cinema имеют одни и те же height, width, они являются абсолютно разными экземплярами.

cinema.width = 2048
print(cinema.width, hd.width) // 2048 1920

enum CompassPoint {
    case north, south, east, west
    mutating func turnNorth() {
        self = .north
    }
}
var currentDirection = CompassPoint.west
let rememberedDirection = currentDirection
currentDirection.turnNorth()

print(currentDirection, rememberedDirection) // north west

/*
Классы - ссылочный тип
*/

// В отличие от типа значений, ссылочный тип не копируется, когда его присваивают переменной или константе, 
// или когда его передают функции. Вместо копирования используется ссылка на существующий экземпляр.

let tenEighty = VideoMode()
tenEighty.resolution = hd
tenEighty.interlaced = true
tenEighty.name = "1080i"
tenEighty.frameRate = 25.0

let alsoTenEighty = tenEighty
alsoTenEighty.frameRate = 30.0

print(tenEighty.frameRate, alsoTenEighty.frameRate) // 30.0 30.0

// Так как это классы ссылочного типа, то экземпляры tenEighty и alsoTenEighty ссылаются на один и 
// тот же экземпляр VideoMode. Фактически получается, что у нас два разных имени для одного единственного экземпляра.

/*
Операторы тождественности
*/

// Иногда бывает полезно выяснить ссылаются ли две константы или переменные на один и тот же экземпляр класса. 
// Для проверки этого в Swift есть два оператора тождественности:
    // Идентичен (===)
    // Не идентичен ( !== )
// Идентичность или тождественность значит, что две константы или переменные ссылаются на один и тот же экземпляр класса.

if tenEighty === alsoTenEighty {
    print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")
}
// "tenEighty and alsoTenEighty refer to the same VideoMode instance."

/*
Указатели
*/

// В Swift константы и переменные, которые ссылаются на экземпляр какого-либо ссылочного типа, аналогичны указателям C, 
// но это не прямые указатели на адрес памяти, и они не требуют от вас написания звездочки(*) для индикации того, 
// что вы создаете ссылку. Вместо этого такие ссылки объявляются как другие константы или переменные в Swift. 

// Стандартная библиотека предоставляет типы указателей и буферов, которые вы можете использовать, 
// если вам нужно напрямую взаимодействовать с указателями.
